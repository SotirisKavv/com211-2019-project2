# Δομές Δεδομένων και Αρχεία

# Άσκηση 2 η: Δομές Δεδομένων στην Κεντρική Μνήμη για δεδομένα δύο διαστάσεων

K-D-Tree: Το KD-Tree (k-dimension) είναι μια δομή δεδομένων τύπου δυαδικού
δένδρου αναζήτησης, με τη διαφορά ότι κάθε κόμβος προστίθεται στη δομή
ανάλογα με τις Κ διαστάσεις που του έχουμε ορίσει να έχει, καθώς έχει παραπάνω
από μία τιμή. Συγκεκριμένα, η τοποθέτηση ενός νέου κόμβου γίνεται με βάση το
αποτέλεσμα της συνάρτησης Depth mod K, όπου depth είναι το βάθος που είμαστε
την παρούσα στιγμή και Κ η διάσταση στην οποία ανήκουν οι τιμές των κόμβων που
περιέχει το δένδρο. Δηλαδή, έστω ένα δένδρο που περιέχει στοιχεία με δύο
διαστάσεις, όπως και στην άσκηση. Οι τιμές είναι της μορφής (x, y). Αν Depth mod 2
= 0, τότε η σύγκριση για να εισχωρηθεί ένα στοιχείο στο δένδρο θα ‘ναι με τις τιμές
του άξονα Χ. Αν η τετμημένη του στοιχείου είναι μεγαλύτερη του κόμβου που
«βρισκόμαστε», τότε το νέο στοιχείο θα εισαχθεί ως δεξί παιδί του κόμβου.
Διαφορετικά, θα εισαχθεί ως αριστερό. Αν Depth mod 2 = 1, ακολουθείται η ίδια
διαδικασία με τη διαφορά ότι πλέον συγκρίνουμε τις τεταγμένες των στοιχείων.
Όσων αφορά την αναζήτηση σε ένα τέτοιο δένδρο, ακολουθείται η ίδια φιλοσοφία
με αυτή του κανονικού Binary Search Tree (BST), όμως σε κάθε κόμβο συγκρίνουμε
την αντίστοιχη διάσταση ανάλογα με το Depth που βρισκόμαστε.

PR QuadTree: Το PR-QuadTree (point region) είναι μια δομή δεδομένων βασιζόμενη
στη λογική του BST, όμως αρκετά διαφορετική. Κάθε κόμβος έχει 4 «παιδιά»: το
Βορειοανατολικό (NE), το Βορειοδυτικό (NW), το Νοτιοανατολικό (SE) και το
Νοτιοδυτικό (SW), και επιπλέον τα στοιχεία του έχουν δύο διαστάσεις και είναι της
μορφής (x, y). Κάθε τέτοιο δένδρο έχει μια Maximum και μια Minimum τιμή για κάθε
άξονα (x και y). Κάθε κόμβος έχει ένα χαρακτηριστικό. Μπορεί να είναι:

`
- EMPTY (άδειος), δηλαδή να μην περιέχει κάποιο στοιχείο,
- ROOT (ρίζα/διακλάδωση), δηλαδή δεν περιέχει κάποιο στοιχείο,
    αλλά έχει τα 4 παιδιά που προαναφέραμε και τέλος,
- LEAF (φύλλο), δηλαδή περιέχει μια τιμή, αλλά δεν έχει παιδιά.
`

Για να εισάγουμε ένα στοιχείο στη δομή, πρώτα ελέγχουμε τον τύπο του κόμβου που
βρισκόμαστε κάθε φορά.


```
▪ Αν είναι EMPTY, τότε απλώς προσθέτουμε το στοιχείο στη θέση
που είμαστε και αλλάζουμε τον τύπο του κόμβου σε LEAF.
▪ Αν είναι ROOT, τότε επαναλαμβάνουμε τη διαδικασία εισαγωγής
στοιχείου στο κατάλληλο παιδί, ανάλογα με τις τιμές (x, y) του
κόμβου και τις Min/Max τιμές που μπορεί να δεχθεί κάθε παιδί.
▪ Αν είναι LEAF, τότε ελέγχουμε πρώτα αν ο κόμβος στον οποίο
βρισκόμαστε έχει τις τιμές του κόμβου που θέλουμε να
εισάγουμε. Αν ναι, τότε τελειώνει η διαδικασία. Αν όχι, επειδή ο
κόμβος περιέχει ήδη μια τιμή, πρώτα «διασπάμε» τον κόμβο στα
4 παιδιά του (το οποίο επιτυγχάνεται με την αρχικοποίηση των 4
υπό-δένδρων με όρια τις min/max και middle, (min+max)/2,
τιμές/όρια του προηγούμενου κόμβου) και ταυτόχρονα
αλλάζουμε τον τύπο του κόμβου σε ROOT, στη συνέχεια
επανεισάγουμε τον υπάρχοντα κόμβο-στοιχείο στο κατάλληλο
δένδρο και τέλος εισάγουμε τον κόμβο που θέλουμε στο
κατάλληλο δένδρο.
```
Η αναζήτηση ενός στοιχείου σ’ αυτήν τη δομή είναι παρόμοια με αυτή σ’ ένα BST,
μόνο που πλέον ελέγχουμε και τις δύο διαστάσεις έχοντας έτσι 4 πιθανά
αποτελέσματα.

**Τεκμηρίωση αποτελεσμάτων Συγκρίσεων**

Εισάγοντας 1000, 10000, 30000, 50000, 70000 και 100000 στοιχεία και στις δύο
δομές είχαμε τα εξής αποτελέσματα και παρατηρήσεις για την κάθε δομή:

```
▪ Για το KD Tree,
o Ήταν αναμενόμενο η αναζήτηση στοιχείων που δεν υπάρχουν στη
δομή να χρειάζεται κατά μέσο όρο περισσότερες συγκρίσεις από μια
επιτυχημένη, δεδομένου ότι αν δεν βρούμε το στοιχείο που ψάχνουμε
στον αναμενόμενο κόμβο, τότε το πρόγραμμά μας συνεχίζει την
αναζήτηση μέχρι να βρει Null κόμβους φτάνοντας πολλές φορές στο
μέγιστο βάθος της δομής.
o Η πολυπλοκότητα του αλγορίθμου αναζήτησης σε ένα KD Tree είναι
O(n) = log 2 (n), καθώς κάθε κόμβος έχει δύο «παιδιά».
```


```
▪ Για το PR QuadTree:
o Και πάλι ήταν αναμενόμενος ο μέσος όρος των βαθών αποτυχημένης
αναζήτησης να ‘ναι μεγαλύτερος από αυτόν των επιτυχημένων, για
τους ίδιους λόγους όπως και στα KD Trees. Η μόνη διαφορά ήταν ότι
περιμέναμε αυτή η διαφορά να ‘ναι μικρότερη (έως και μηδενική)
δεδομένου ότι όλα τα στοιχεία βρίσκονται στα «φύλλα» του δένδρου
και άρα τα στοιχεία τελικά ή θα βρεθούν στο βάθος των φύλλων ή όχι.
o Ο αλγόριθμος αναζήτησης στα PR QuadTrees έχει πολυπλοκότητα
O(n) = log 4 (n), διότι κάθε κόμβος (ROOT) έχει 4 «παιδιά».
```

▪ Πιο γρήγορη δομή ως προς την αναζήτηση στοιχείων φαίνεται εκ του
αποτελέσματος να είναι η PR QuadTree, καθώς βρίσκει (ή όχι) το στοιχείο
που θέλουμε κάνοντας λιγότερες συγκρίσεις/φτάνοντας σε μικρότερο βάθος
σε αντίθεση με τα KD Trees που φτάνουν σε περίπου διπλάσιο βάθος.
▪ Παρά το γεγονός ότι η αναζήτηση γίνεται πιο γρήγορα, η εισαγωγή ενός
στοιχείου σε ένα PR QuadTree είναι πιο περίπλοκη από αυτή σε ένα KD Tree.

**Πηγές**

- https://en.wikipedia.org/wiki/K-d_tree
- https://www.geeksforgeeks.org/k-dimensional-tree/
- https://en.wikipedia.org/wiki/Quadtree
- https://opendsa-server.cs.vt.edu/ODSA/Books/CS3/html/PRquadtree.html


